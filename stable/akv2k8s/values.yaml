# Default values 
name: akv2k8s

rbac:
  # Specifies whether RBAC resources should be created
  create: true
  podSecurityPolicies:
    {}

crds:
  enabled: true
  create: true
  keep: true

addAzurePodIdentityException: false # see https://github.com/Azure/aad-pod-identity/blob/master/docs/readmes/README.app-exception.md
cloudConfig: /etc/kubernetes/azure.json

controller:
  name: controller
  image:
    repository: spvest/azure-keyvault-controller
    tag: 1.2.0-beta.14
    pullPolicy: IfNotPresent
    #pullSecret: secretName

  logLevel: info
  logFormat: fmt # fmt or json

  keyVaultAuth: azureCloudConfig # azureCloudConfig (aks credentials), environment (custom)  

  serviceAccount:
    create: true
    ## The name of the ServiceAccount to use.
    ## If not set and create is true, a name is generated using the fullname template
    name:

  env: {}
  # Uncomment to use client-id / secret - see https://akv2k8s.io/security/authentication/#custom-authentication-options
  #   AZURE_TENANT_ID: <tenantId>
  #   AZURE_CLIENT_ID: <clientId>
  #   AZURE_CLIENT_SECRET: <clientSecret>
  labels: {}
  podLabels: {}

  resources: {}
  nodeSelector: {}
  tolerations: []
  affinity: {}

env_injector:
  enabled: true
  name: env-injector

  keyVaultAuth: cloudConfig # cloudConfig, environment,  
  authService: true # set to false to provide azure key vault credentials locally (through e.g. env vars) in each pod

  image:
    repository: spvest/azure-keyvault-webhook
    tag: 1.2.0-beta.2
    pullPolicy: IfNotPresent

  replicaCount: 2

  envImage:
    repository: spvest/azure-keyvault-env
    tag: 1.2.0-beta.1

  logLevel: Info
  logFormat: fmt # ftm or json

  certificate:
    useCertManager: false
    custom:
      enabled: false
      server:
        tls:
          crt:
          key:
      ca:
        crt:

  securityContext:
    allowPrivilegeEscalation: true # must be true if using aks identity
  #   runAsUser: 65534

  namespaceLabelSelector:
    label: 
      name: azure-key-vault-env-injection
      value: enabled

  caBundleConfigMapName: akv2k8s-ca

  dockerImageInspection:
    timeout: 20 # Timeout in seconds
    useAksCredentialsWithACS: true # Only applicable if runningInsideAzureAks is also true

  service:
    name: azure-keyvault-secrets-webhook
    type: ClusterIP
    externalTlsPort: 443
    internalTlsPort: 443
    externalHttpPort: 80
    internalHttpPort: 80

  metrics:
    enabled: false
    port: 8443
    serviceMonitor:
      enabled: false
      scheme: https
      tlsConfig:
        insecureSkipVerify: true
      additionalLabels: {}

  serviceAccount:
    create: true
    ## The name of the ServiceAccount to use.
    ## If not set and create is true, a name is generated using the fullname template
    name:

  env: {}
  # Uncomment to use client-id / secret - see https://akv2k8s.io/security/authentication/#custom-authentication-options
  #   AZURE_TENANT_ID: <tenantId>
  #   AZURE_CLIENT_ID: <clientId>
  #   AZURE_CLIENT_SECRET: <clientSecret>
  labels: {}
  podLabels: {}

  ## See `kubectl explain poddisruptionbudget.spec` for more
  ## ref: https://kubernetes.io/docs/tasks/run-application/configure-pdb/
  podDisruptionBudget:
    enabled: true
    minAvailable: 1
  #  maxUnavailable: 1

  # What will happen if the webhook fails? Ignore (continue) or Fail (prevent Pod from starting)?
  failurePolicy: Fail

  # https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#matching-requests-namespaceselector
  namespaceSelector:
    # Prevent env injection for pods in kube-system as recomended: https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#avoiding-operating-on-the-kube-system-namespace
    matchExpressions:
    - key: name
      operator: NotIn
      values:
      - kube-system

  resources: {}
  nodeSelector: {}
  tolerations: []
  affinity: {}